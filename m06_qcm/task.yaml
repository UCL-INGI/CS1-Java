author: Olivier BONAVENTURE
context: "============================\nMission 6. Classes et Objets\n============================\n\
  \n\nCes questions supposent que vous avez lu les sections suivantes du livre de\
  \ référence |jn|_\n\n  - |jn5.1|_\n\n    - |jn5.1.1|_\n    - |jn5.1.2|_\n    - |jn5.1.3|_\n\
  \n  - |jn5.2|_\n\n    - |jn5.2.1|_\n    - |jn5.2.2|_\n    - |jn5.2.3|_\n\n  - |jn5.4|_\n\
  \n    - |jn5.4.1|_\n    - |jn5.4.2|_\n    - |jn5.4.3|_\n\nainsi que l'API de la\
  \ classe |TextIO|_.  Les sections vues précédemment restent bien entendu d'actualité.\n\
  \n.. _jn: http://math.hws.edu/javanotes/\n.. |jn| replace:: JavaNotes\n\n.. _jn5.1\
  \ : http://math.hws.edu/javanotes/c5/s1.html\n.. |jn5.1| replace:: `5.1 : Objects,\
  \ Instance Methods, and Instance Variables`\n\n.. _jn5.1.1 : http://math.hws.edu/javanotes/c5/s1.html#OOP.1.1\n\
  .. |jn5.1.1| replace:: `5.1.1 : Objects, Classes, and Instances`\n\n.. _jn5.1.2\
  \ : http://math.hws.edu/javanotes/c5/s1.html#OOP.1.2\n.. |jn5.1.2| replace:: `5.1.2\
  \ : Fundamentals of Objects`\n\n.. _jn5.1.3 : http://math.hws.edu/javanotes/c5/s1.html#OOP.1.3\n\
  .. |jn5.1.3| replace:: `5.1.3 : Getters and Setters`\n\n.. _jn5.2 : http://math.hws.edu/javanotes/c5/s2.html\n\
  .. |jn5.2| replace:: `5.2 : Constructors and Object Initialization`\n\n.. _jn5.2.1\
  \ : http://math.hws.edu/javanotes/c5/s2.html#OOP.2.1\n.. |jn5.2.1| replace:: `5.2.1\
  \ : Initializing Instance Variables`\n\n.. _jn5.2.2 : http://math.hws.edu/javanotes/c5/s2.html#OOP.2.2\n\
  .. |jn5.2.2| replace:: `5.2.2 : Constructors`\n\n.. _jn5.2.3 : http://math.hws.edu/javanotes/c5/s2.html#OOP.2.3\n\
  .. |jn5.2.3| replace:: `5.2.3 : Garbage Collection`\n\n.. _jn5.4 : http://math.hws.edu/javanotes/c5/s4.html\n\
  .. |jn5.4| replace:: `5.4 : Programming Example: Card, Hand, Deck`\n\n.. _jn5.4.1\
  \ : http://math.hws.edu/javanotes/c5/s4.html#OOP.4.1\n.. |jn5.4.1| replace:: `5.4.1\
  \ : Designing the classes`\n\n.. _jn5.4.2 : http://math.hws.edu/javanotes/c5/s4.html#OOP.4.2\n\
  .. |jn5.4.2| replace:: `5.4.2 : The Card Class`\n\n.. _jn5.4.3 : http://math.hws.edu/javanotes/c5/s4.html#OOP.4.3\n\
  .. |jn5.4.3| replace:: `5.4.3 : Example: A Simple Card Game`\n\n.. _TextIO : http://math.hws.edu/eck/cs124/javanotes6/source/TextIO.java\n\
  .. |TextIO| replace:: ``TextIO``\n"
environment: mcq
limits: {memory: '100', output: '2', time: '30'}
name: 'Mission 6: QCM'
network_grading: false
order: 105
problems:
  q1:
    choices:
    - {text: '

        * Ce code définit une classe ``PairOfDice``.

        * Chaque instance de ``PairOfDice`` a sa propre copie de ``die1``.

        * ``roll()`` est une méthode d''instance de la classe ``PairOfDice``.

        ', valid: true}
    - {text: '

        * Une instance de ``PairOfDice`` est un objet.

        * ``die1`` est une variable d''instance de la classe ``PairOfDice``.

        * L''effet de l''exécution de la méthode ``roll()`` dépend de l''instance
        à laquelle elle s''applique.

        ', valid: true}
    - {feedback: '

        Ce code définit une *classe*, pas un objet.

        ', text: '

        * Ce code définit un objet ``PairOfDice``.

        * ``die1`` est une variable d''instance de la classe ``PairOfDice``.

        * ``roll()`` est une méthode d''instance de la classe ``PairOfDice``.

        '}
    - {feedback: '

        ``die1`` est une variable d''instance, elle n''est pas partagée.

        ', text: '

        * Une instance de ``PairOfDice`` est un objet.

        * ``die1`` est une variable partagée entre les instances de ``PairOfDice``.

        * ``roll()`` est une méthode d''instance de la classe ``PairOfDice``.

        '}
    - {feedback: '

        ``roll()`` est une méthode d''instance.

        ', text: '

        * Une instance de ``PairOfDice`` est un objet.

        * Chaque instance de ``PairOfDice`` a sa propre copie de ``die1``.

        * ``roll()`` est une méthode de classe de la classe ``PairOfDice``.

        '}
    - {feedback: '

        La notion d''instance s''applique aux classes et aux objets, pas aux variables.

        ', text: '

        * Une instance de ``die1`` est un entier.

        * Chaque instance de ``PairOfDice`` a sa propre copie de ``die1``.

        * L''effet de l''exécution de la méthode ``roll()`` dépend de l''instance
        à laquelle elle s''applique.

        '}
    - {feedback: '

        Une variable locale est définie à l''intérieur du corps d''une méthode.

        ', text: '

        * Ce code définit une classe ``PairOfDice``.

        * ``die1`` est une variable locale de la classe ``PairOfDice``.

        * L''effet de l''exécution de la méthode ``roll()`` dépend de l''instance
        à laquelle elle s''applique.

        '}
    - {feedback: '

        ``roll()`` est une méthode d''instance et utilise les variables d''instance
        de la classe.

        ', text: '

        * Une instance de ``PairOfDice`` est un objet.

        * ``die1`` est une variable d''instance de la classe ``PairOfDice``.

        * L''effet de l''exécution de la méthode ``roll()`` est indépendant de l''instance
        à laquelle elle s''applique.

        '}
    header: "\nSoit le code Java suivant\n\n.. code-block:: java\n\n    public class\
      \ PairOfDice {\n\n        public int die1;   // Number showing on the first\
      \ die.\n        public int die2;   // Number showing on the second die.\n\n\
      \        /**\n         * @pre val1, val2 are valid die values\n         * @post\
      \ creates a pair of dice that are initially\n         *       showing the values\
      \ val1 and val2.\n         */\n        public PairOfDice(int val1, int val2)\
      \ {\n             die1 = val1;\n             die2 = val2;\n        }\n\n   \
      \     /**\n         * @pre -\n         * @post rolled the dice by setting each\
      \ of the dice\n         *       to be a random number between 1 and 6.\n   \
      \      */\n        public void roll() {\n             die1 = (int)(Math.random()*6)\
      \ + 1;\n             die2 = (int)(Math.random()*6) + 1;\n        }\n\n    }\
      \ // end class PairOfDice\n\nLaquelle des propositions ci-dessous est correcte ?\n"
    limit: 3
    name: Classe, objets et instances
    type: multiple-choice
  q2:
    choices:
    - {text: ".. code-block:: java\n\n   public class Fraction {\n       private int\
        \ num;  // numérateur\n       private int den;  // dénominateur\n\n      \
        \ public Fraction(int n, int d) {\n           num = n;\n           den = d;\n\
        \       }\n\n       public double valeur() {\n           return ((double)\
        \ num) / ((double) den);\n       }\n   }\n", valid: true}
    - {feedback: '

        La méthode ``valeur`` doit être une méthode d''instance, pour avoir accès
        aux variables d''instance de chaque instance de ``Fraction``.

        ', text: ".. code-block:: java\n\n   public class Fraction {\n       private\
        \ int num;  // numérateur\n       private int den;  // dénominateur\n\n  \
        \     public Fraction(int n, int d) {\n           num = n;\n           den\
        \ = d;\n       }\n\n       public static double valeur() {\n           return\
        \ ((double) num) / ((double) den);\n       }\n   }\n"}
    - {feedback: '

        La signature du constructeur est incorrecte.

        ', text: ".. code-block:: java\n\n   public class Fraction {\n       private\
        \ int num;  // numérateur\n       private int den;  // dénominateur\n\n  \
        \     public void Fraction(int n, int d) {\n           num = n;\n        \
        \   den = d;\n       }\n\n       public double valeur() {\n           return\
        \ ((double) num) / ((double) den);\n       }\n   }\n"}
    - {feedback: '

        La construction ''new Fraction(n,d)'' fait appel au constructeur, elle ne
        doit pas se trouver dans la définition de ce constructeur.

        ', text: ".. code-block:: java\n\n   public class Fraction {\n       private\
        \ int num;  // numérateur\n       private int den;  // dénominateur\n\n  \
        \     public Fraction(int n, int d) {\n           new Fraction(n,d);\n   \
        \        num = n;\n           den = d;\n       }\n\n       public double valeur()\
        \ {\n           return ((double) num) / ((double) den);\n       }\n   }\n"}
    - {feedback: '

        Dans ``valeur``, il n''est pas nécessaire de passer la fraction comme paramètre.

        ', text: ".. code-block:: java\n\n   public class Fraction {\n       private\
        \ int num = 0;  // numérateur\n       private int den = 1;  // dénominateur\n\
        \n       public Fraction(int n, int d) {\n           num = n;\n          \
        \ den = d;\n       }\n\n       public double valeur(Fraction f) {\n      \
        \     return ((double) num) / ((double) den);\n       }\n   }\n"}
    header: "\nLaquelle des définitions suivantes définit correctement une classe\
      \ dont les instances représentent des fractions (num / den), telle que les instructions\n\
      \n.. code-block:: java\n\n  Fraction f = new Fraction(3,4);\n  System.out.println(f.valeur());\n\
      \nimprime le résultat ``0.75``  ?\n"
    limit: 3
    name: Définition de classe
    type: multiple-choice
  q3:
    choices:
    - {text: '

        1. Erreur à l''exécution: ``f`` est une référence nulle

        2. Imprime "0.75"

        3. Erreur à l''exécution: ``f`` est une référence nulle

        ', valid: true}
    - {feedback: '

        Dans le cas 1, ``f`` n''est pas initialisé donc ne référencie aucun objet.

        ', text: '

        1. Imprime "0.0"

        2. Imprime "0.75"

        3. Erreur à l''exécution: ``f`` est une référence nulle

        '}
    - {feedback: '

        La référence ``null`` ne référencie aucun objet, le cas 3 est identique au
        cas 1.

        ', text: '

        1. Erreur à l''exécution: ``f`` est une référence nulle

        2. Imprime "0.75"

        3. Imprime "0.0"

        '}
    - {feedback: '

        Les trois sont corrects par rapport à la syntaxe et aux types, la compilation
        ne pose pas de problème.

        ', text: '

        1. Erreur de compilation

        2. Imprime "0.75"

        3. Erreur de compilation

        '}
    - {feedback: '

        Dans les cas 1 et 3, ``f`` ne référencie aucun objet.

        ', text: '

        1. Imprime "0.0"

        2. Imprime "0.75"

        3. Imprime "0.0"

        '}
    header: "\nSur base de la définition de la question précédente, que se passe-t-il\
      \ si on tente de compiler et d'exécuter (séparément) les trois suites d'instructions\
      \ suivantes ?\n\n1.\n\n.. code-block:: java\n\n    Fraction f;\n    System.out.println(f.valeur());\n\
      \n2.\n\n.. code-block:: java\n\n    Fraction f = new Fraction(3, 4);\n    System.out.println(f.valeur());\n\
      \n3.\n\n.. code-block:: java\n\n    Fraction f = null;\n    System.out.println(f.valeur());\n\
      \n"
    limit: 3
    name: Initialisation d'objets
    type: multiple-choice
  q4:
    choices:
    - {text: ".. code-block:: java\n\n   public int getNum() {\n       return num;\n\
        \   }\n   public void setNum(int n) {\n       num = n;\n   }\n", valid: true}
    - {feedback: '

        Il s''agit de permettre au reste du programme de lire et modifier la variable,
        pas à l''utilisateur.

        ', text: ".. code-block:: java\n\n   public int getNum() {\n       System.out.println(num);\n\
        \   }\n   public void setNum() {\n       num = TextIO.getInt();\n   }\n"}
    - {feedback: '

        La méthode ``getNum()`` ne sert à rien tel que définie ici.

        ', text: ".. code-block:: java\n\n   public void getNum(int n) {\n       n\
        \ = num;\n   }\n   public void setNum(int n) {\n       num = n;\n   }\n"}
    - {feedback: '

        Dans ``setNum()``, pourquoi retourner la valeur modifiée?

        ', text: ".. code-block:: java\n\n   public int getNum() {\n       return\
        \ num;\n   }\n   public int setNum(int n) {\n       num = n;\n       return\
        \ num;\n   }\n"}
    - {feedback: '

        Ceci peut fonctionner, mais pourquoi prendre des noms de méthode qui ne signifient
        rien et violent les conventions usuelles ?  La lisibilité du code est un facteur
        de qualité important.

        ', text: ".. code-block:: java\n\n   public int f1() {\n       return num;\n\
        \   }\n   public void f2(int n) {\n       num = n;\n   }\n"}
    header: "\nComment définirait-on un accesseur (getter) et un mutateur (setter)\
      \ pour la variable d'instance ``num`` de la classe ``Fraction`` à la question\
      \ 2, tels qu'utilisés dans l'exemple suivant\n\n.. code-block:: java\n\n  Fraction\
      \ f = new Fraction(3, 4);\n  System.out.println(f.getNum());  // imprime \"\
      3\"\n  f.setNum(5);\n  System.out.println(f.getNum());  // imprime \"5\"\n"
    limit: 3
    name: Accesseurs et mutateurs
    type: multiple-choice
  q5:
    choices:
    - {text: ".. code-block:: java\n\n   // un étudiant non-bisseur\n   public Etudiant(String\
        \ n, String m) {\n       nom = n;\n       matricule = m;\n   }\n", valid: true}
    - {text: ".. code-block:: java\n\n   // un étudiant anonyme\n   public Etudiant(String\
        \ m, boolean b) {\n       nom = \"[anonyme]\";\n       matricule = m;\n  \
        \     bisseur = b;\n   }\n", valid: true}
    - {feedback: '

        Le constructeur doit avoir le nom de la classe.

        ', text: ".. code-block:: java\n\n   // un étudiant bisseur\n   public Bisseur(String\
        \ n, String m) {\n       nom = n;\n       matricule = m;\n       bisseur =\
        \ true;\n   }\n"}
    - {feedback: '

        Un constructeur ne peut pas être déclaré ``static``.

        ', text: ".. code-block:: java\n\n   // un étudiant sans matricule\n   public\
        \ static Etudiant(String n, boolean b) {\n       nom = n;\n       matricule\
        \ = \"000000\";\n       bisseur = b;\n   }\n"}
    - {feedback: '

        La variable ``nom`` n''est pas initialisée.

        ', text: ".. code-block:: java\n\n   // un étudiant anonyme\n   public Etudiant(String\
        \ m) {\n       matricule = m;\n       bisseur = false;\n   }\n"}
    - {feedback: '

        L''instruction ``return`` est superflue et interdite dans un constructeur.

        ', text: ".. code-block:: java\n\n   // un étudiant non-bisseur\n   public\
        \ Etudiant(String n, String m) {\n       nom = n;\n       matricule = m;\n\
        \       return;\n   }\n"}
    header: "\nSoit la classe suivante\n\n.. code-block:: java\n\n    public class\
      \ Etudiant {\n        String nom;\n        String matricule;\n        boolean\
      \ bisseur = false;\n\n        // ... méthodes\n    }\n\nParmi les définitions\
      \ de constructeurs suivantes, laquelle est correcte ?\n"
    limit: 3
    name: Constructeurs
    type: multiple-choice
  q6:
    choices:
    - {text: ".. code-block:: java\n\n   15,20\n   40,40\n   40,0\n", valid: true}
    - {feedback: '

        Après l''instruction ``c1 = c2``, ``c1`` et ``c2`` sont des références au
        même objet; ``c2.ajout(20)`` agit aussi sur l''objet référencé par ``c1``.

        ', text: ".. code-block:: java\n\n   15,20\n   20,40\n   20,0\n"}
    - {feedback: '

        Après ``c2 = new Compteur(0)``, seule ``c2`` réfère au nouvel objet créé;
        ``c1`` est inchangé.

        ', text: ".. code-block:: java\n\n   15,20\n   40,40\n   0,0\n"}
    - {feedback: '

        Attention à l''instruction ``c1 == c2``.

        ', text: ".. code-block:: java\n\n   15,20\n   25,40\n   25,0\n"}
    - {feedback: '

        Que fait la méthode ``ajout()`` ?

        ', text: ".. code-block:: java\n\n   10,20\n   20,20\n   20,0\n"}
    header: "\nSoit la classe ``Compteur`` suivante\n\n.. code-block:: java\n\n  \
      \  public class Compteur {\n        private int compte;  // le compteur\n\n\
      \        public Compteur(int n) {\n            compte = n;\n        }\n\n  \
      \      public void ajout(int n) {\n            compte = compte + n;\n      \
      \  }\n\n        public int valeur() {\n            return compte;\n        }\n\
      \    }\n\nQu'imprime le programme suivant\n\n.. code-block:: java\n\n      \
      \  Compteur c1 = new Compteur(10);\n        Compteur c2 = new Compteur(20);\n\
      \        c1.ajout(5);\n        System.out.println(c1.valeur() + \",\" + c2.valeur());\n\
      \        c1.ajout(10);\n        c1 = c2;\n        c2.ajout(20);\n        System.out.println(c1.valeur()\
      \ + \",\" + c2.valeur());\n        c2 = new Compteur(0);\n        System.out.println(c1.valeur()\
      \ + \",\" + c2.valeur());\n"
    limit: 3
    name: Références
    type: multiple-choice
  q7:
    choices:
    - {text: ".. code-block:: java\n\n       public String toString() {\n        \
        \   String s = nom + \" (\" + matricule + \")\";\n           if (bisseur)\
        \ {\n               s = s + \" bisseur\";\n           } else {\n         \
        \      s = s + \" non-bisseur\";\n           }\n           return s;\n   \
        \    }\n", valid: true}
    - {feedback: '

        La méthode doit s''appeler ``toString`` pour pouvoir être appelée implicitement,
        par exemple dans ``System.out.println``.

        ', text: ".. code-block:: java\n\n       public String asString() {\n    \
        \       String s = nom + \" (\" + matricule + \")\";\n           if (bisseur)\
        \ {\n               s = s + \" bisseur\";\n           } else {\n         \
        \      s = s + \" non-bisseur\";\n           }\n           return s;\n   \
        \    }\n"}
    - {feedback: '

        La méthode doit avoir exactement la signature ``String toString()`` pour pouvoir
        être appelée implicitement, par exemple dans ``System.out.println``.

        ', text: ".. code-block:: java\n\n       public String toString(String s)\
        \ {\n           s = nom + \" (\" + matricule + \")\";\n           if (bisseur)\
        \ {\n               s = s + \" bisseur\";\n           } else {\n         \
        \      s = s + \" non-bisseur\";\n           }\n           return s;\n   \
        \    }\n"}
    - {feedback: '

        Seul le premier ``return`` exécuté sera pris en compte.  Révisez les appels
        de méthodes.

        ', text: ".. code-block:: java\n\n       public String toString() {\n    \
        \       return nom + \" (\" + matricule + \")\";\n           if (bisseur)\
        \ {\n               return \" bisseur\";\n           } else {\n          \
        \     return \" non-bisseur\";\n           }\n       }\n"}
    - {feedback: '

        La méthode ``toString()`` doit retourner le string et non l''imprimer.

        ', text: ".. code-block:: java\n\n       public String toString() {\n    \
        \       System.out.println(nom + \" (\" + matricule + \")\";\n           if\
        \ (bisseur) {\n               System.out.println(\" bisseur\");\n        \
        \   } else {\n               System.out.println(\" non-bisseur\");\n     \
        \      }\n       }\n"}
    - {feedback: '

        Cette méthode ne retourne rien...

        ', text: ".. code-block:: java\n\n       public String toString() {\n    \
        \       String s = nom + \" (\" + matricule + \")\";\n           if (bisseur)\
        \ {\n               s = s + \" bisseur\";\n           } else {\n         \
        \      s = s + \" non-bisseur\";\n           }\n       }\n"}
    header: "\nComment écrirait-on une méthode pour la classe ``Etudiant`` de la question\
      \ 5, telle que le code suivant\n\n.. code-block:: java\n\n    Etudiant etud\
      \ = new Etudiant(\"John Doe\", \"987612\");\n    System.out.println(etud);\n\
      \naffiche le texte suivant :\n\n    ``John Doe (987612) non-bisseur``\n\n"
    limit: 3
    name: toString()
    type: multiple-choice
  q8:
    choices:
    - {text: ".. code-block:: java\n\n   TextIO.readFile(\"README\");\n   while (!TextIO.eof())\
        \ {\n       System.out.println(TextIO.getln());\n   }\n", valid: true}
    - {feedback: '

        Cette version produira une erreur à la fin du fichier.

        ', text: ".. code-block:: java\n\n   TextIO.readFile(\"README\");\n   while\
        \ (true) {\n       System.out.println(TextIO.getln());\n   }\n"}
    - {feedback: '

        L''utilisation de ``eof()`` et ``getln()`` ne correspond pas à leur signature
        documentée dans l''API.  Ce code donne donne une erreur de compilation.

        ', text: ".. code-block:: java\n\n   while (!TextIO.eof(\"README\")) {\n \
        \      System.out.println(TextIO.getln(\"README\"));\n   }\n"}
    - {feedback: '

        Ces noms de méthodes n''existent pas dans ``TextIO``.

        ', text: ".. code-block:: java\n\n   TextIO.open(\"README\");\n   while (TextIO.hasNext())\
        \ {\n       System.out.println(TextIO.next());\n   }\n"}
    - {feedback: '

        Deux erreurs: un caractère manquant (qui change tout) dans la condition du
        ``while`` et l''utilisation inappropriée de ``getWord()``.

        ', text: ".. code-block:: java\n\n   TextIO.readFile(\"README\");\n   while\
        \ (TextIO.eof()) {\n       System.out.println(TextIO.getWord());\n   }\n"}
    - {feedback: '

        Ce n''est pas ainsi qu''on utilise ``TextIO.eof()``.

        ', text: ".. code-block:: java\n\n   TextIO.readFile(\"README\");\n   String\
        \ s = TextIO.getln();\n   while (!TextIO.eof(s)) {\n       System.out.print(s);\n\
        \       s = TextIO.getln();\n   }\n"}
    header: '

      Parmi les portions de programme suivantes, laquelle permet d''imprimer à la
      console le contenu du fichier ``README`` ?

      '
    limit: 3
    name: ' TextIO'
    type: multiple-choice
