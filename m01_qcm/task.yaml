author: Olivier BONAVENTURE
context: "=========================\nMission 1 : Mise en Route\n=========================\n\
  \nCes questions ont pour objectif de vous permettre de tester vous-même votre compréhension\
  \ de la matière couverte par cette mission de mise en route.\n\nCes questions supposent\
  \ que vous avez lu les sections suivantes du livre de référence |jn|_ :\n\n\n -\
  \ |jn1|_\n\n   - |jn1.1|_\n   - |jn1.2|_\n   - |jn1.3|_\n   - |jn1.4|_\n   - |jn1.5|_\n\
  \   - |jn1.7|_\n\n - |jn2|_\n\n   - |jn2.1|_\n   - |jn2.2|_\n   - |jn2.3|_ (sauf\
  \ |jn2.3.3|_)\n   - |jn2.5|_ (sauf |jn2.5.7|_)\n   - |jn2.6|_ (sauf |jn2.6.3|_)\n\
  \n - |jn3|_\n\n   - |jn3.1|_\n\n.. _jn: http://math.hws.edu/javanotes/\n.. |jn|\
  \ replace:: JavaNotes\n\n.. _jn1: http://math.hws.edu/javanotes/c1/index.html\n\
  .. |jn1| replace:: `1 : Overview: The Mental Landscape`\n\n.. _jn1.1: http://math.hws.edu/javanotes/c1/s1.html\n\
  .. |jn1.1| replace:: `1.1 : The Fetch and Execute Cycle: Machine Language`\n\n..\
  \ _jn1.2: http://math.hws.edu/javanotes/c1/s2.html\n.. |jn1.2| replace:: `1.2 :\
  \ Asynchronous Events: Polling Loops and Interrupts`\n\n.. _jn1.3: http://math.hws.edu/javanotes/c1/s3.html\n\
  .. |jn1.3| replace:: `1.3 : The Java Virtual Machine`\n\n.. _jn1.4: http://math.hws.edu/javanotes/c1/s4.html\n\
  .. |jn1.4| replace:: `1.4 : Fundamental Building Blocks of Programs`\n\n.. _jn1.5:\
  \ http://math.hws.edu/javanotes/c1/s5.html\n.. |jn1.5| replace:: `1.5 : Objects\
  \ and Object-oriented Programming`\n\n.. _jn1.7: http://math.hws.edu/javanotes/c1/s7.html\n\
  .. |jn1.7| replace:: `1.7 : The Internet and Beyond`\n\n.. _jn2 : http://math.hws.edu/javanotes/c2/index.html\n\
  .. |jn2| replace:: `2 : Programming in the Small I: Names and Things`\n\n.. _jn2.1:\
  \ http://math.hws.edu/javanotes/c2/s1.html\n.. |jn2.1| replace:: `2.1 : The Basic\
  \ Java Application`\n\n.. _jn2.2: http://math.hws.edu/javanotes/c2/s2.html\n.. |jn2.2|\
  \ replace:: `2.2 : Variables and the Primitive Types`\n\n.. _jn2.3: http://math.hws.edu/javanotes/c2/s3.html\n\
  .. |jn2.3| replace:: `2.3 : Strings, Objects, Enums, and Subroutines`\n\n.. _jn2.3.3:\
  \ http://math.hws.edu/javanotes/c2/s3.html#basics.3.3\n.. |jn2.3.3| replace:: `2.3.3\
  \ : Introduction to Enums`\n\n.. _jn2.5 : http://math.hws.edu/javanotes/c2/s5.html\n\
  .. |jn2.5| replace:: `2.5 : Details of Expressions`\n\n.. _jn2.5.7: http://math.hws.edu/javanotes/c2/s5.html#basics.5.7\n\
  .. |jn2.5.7| replace:: `2.5.7 : Type Conversion of Strings`\n\n.. _jn2.6: http://math.hws.edu/javanotes/c2/s6.html\n\
  .. |jn2.6| replace:: `2.6 : Programming Environments`\n\n.. _jn2.6.3: http://math.hws.edu/javanotes/c2/s6.html#basics.6.3\n\
  .. |jn2.6.3| replace:: `2.6.3 : IDEs and Eclipse`\n\n.. _jn3 : http://math.hws.edu/javanotes/c3/index.html\n\
  .. |jn3| replace:: `3 : Programming in the Small II: Control`\n\n.. _jn3.1: http://math.hws.edu/javanotes/c3/s1.html\n\
  .. |jn3.1| replace:: `3.1 : Blocks, Loops, and Branches`\n"
environment: mcq
limits: {memory: '100', output: '2', time: '30'}
name: 'Mission 1: QCM'
network_grading: false
order: 0
problems:
  q1:
    choices:
    - {text: "\n.. code:: java\n\n   int a=12;\n   int b=42352;\n", valid: true}
    - {text: "\n.. code:: java\n\n   int var1=-12;\n   int var2=42352;\n", valid: true}
    - {feedback: '

        En Java, une variable est initialisée en utilisant une constante ou une expression
        qui s''évalue avec le type de la variable.

        ', text: "\n.. code:: java\n\n   int var1=-12;\n   int var2=-var1;\n", valid: true}
    - {text: "\n.. code:: java\n\n   int var_1=-12100;\n   int var_2=42352;\n", valid: true}
    - {feedback: '

        En Java, un nom de variable ne peut jamais contenir d''espace.

        ', text: "\n.. code:: java\n\n   int var=1;\n   int ma variable=2;\n"}
    - {feedback: '

        En Java, l''expression ``1.2`` est un nombre réel et non un nombre entier.

        ', text: "\n.. code:: java\n\n   int var=1.2;\n   int d=2;\n"}
    - {feedback: '

        En Java, l''expression ``\`1\``` correspond au caractère ``1``. Ce n''est
        donc pas un nombre entier.

        ', text: "\n.. code:: java\n\n   int var1='1';\n   int var2=2;\n"}
    - {feedback: '

        En Java, les entiers ne peuvent représenter que les nombres entre ``-2147483648``
        et ``2147483647``. Le nombre ``123456789123456789123456789`` est trop grand.
        Il ne peut être représenté que sous la forme d''un ``long``.

        ', text: "\n.. code:: java\n\n   int a=123456789123456789123456789;\n   int\
        \ b=2;\n"}
    header: '

      Parmi les fragments de code Java suivants, quels sont ceux qui correspondent
      à des initialisations correctes de variables entières ?

      '
    limit: 3
    name: Initialisation de variables
    type: multiple-choice
  q10:
    choices:
    - {text: "\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=0;\n   int sum=0; // la somme\n   while(count <n) {\n      sum=sum+count;\n\
        \      count=count+1;\n   }\n   // la variable sum contient la somme des\n\
        \   // n premiers entiers positifs\n", valid: true}
    - {text: "\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=n;\n   int sum=0; // la somme\n   while(count>0) {\n      sum=sum+count;\n\
        \      count=count-1;\n   }\n   // la variable sum contient la somme des\n\
        \   // n premiers entiers positifs\n", valid: true}
    - {feedback: '

        Cette boucle ne se termine pas.

        ', text: "\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=0;\n   int sum=0; // la somme\n   while(count <n) {\n      sum=sum+count;\n\
        \      count=count-1;\n   }\n   // la variable sum contient la somme des\n\
        \   // n premiers entiers positifs\n"}
    - {feedback: '

        Quelle est la somme calculée par cette boucle ``while`` ?

        ', text: "\n.. code:: java\n\n   int n=...;  // à initialiser correctement\n\
        \   int sum=0; // la somme\n   while( n>1 ) {\n      sum=sum+n;\n      n=n-1;\n\
        \   }\n"}
    - {feedback: '

        L''expression qui sert de garde à une boucle ``while`` doit être une expression
        booléenne. ``sum=sum+n`` n''est pas une expression booléenne et ce programme
        n''est pas syntaxiquement valide.

        ', text: "\n.. code:: java\n\n   int n=...;  // à initialiser correctement\n\
        \   int sum=0; // la somme\n   while( sum=sum+n ) {\n      n=n-1;\n   }\n\
        \   // la variable sum contient la somme des\n   // n premiers entiers positifs\n"}
    - {feedback: "\nCe programme illustre une subtilité de l'utilisation des blocs\
        \ avec le langage Java. Sans accolades, la boucle ``while`` porte uniquement\
        \ sur l'instruction qui la suit. Ce code est donc équivalent au code ci-dessous\
        \ :\n\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=n;\n   int sum=0; // la somme\n   while(count>0) {\n      sum=sum+count;\n\
        \   }\n   count=count-1;\n\nDans ce fragment de code, la variable ``count``\
        \ n'est pas décrémentée dans le corps de la boucle et celle-ci ne se termine\
        \ done jamais. Pour éviter ce genre de problèmes, il est préférable de *toujours*\
        \ utiliser des accolades pour délimiter le bloc d'une boucle ``while``.\n",
      text: "\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=n;\n   int sum=0; // la somme\n   while(count>0)\n      sum=sum+count;\n\
        \      count=count-1;\n   // la variable sum contient la somme des\n   //\
        \ n premiers entiers positifs\n"}
    - {feedback: "\nCe programme illustre une subtilité de l'utilisation des blocs\
        \ avec le langage Java. Sans accolades, la boucle ``while`` porte uniquement\
        \ sur l'instruction qui la suit. Ce code est donc équivalent au code ci-dessous\
        \ :\n\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=0;\n   int sum=0; // la somme\n   while(count<n) {\n      sum=sum+count;\n\
        \   }\n   count=count+1;\n\nDans ce fragment de code, la variable ``count``\
        \ n'est pas incrémentée dans le corps de la boucle et celle-ci ne se termine\
        \ done jamais. Pour éviter ce genre de problèmes, il est préférable de *toujours*\
        \ utiliser des accolades pour délimiter le bloc d'une boucle ``while``.\n",
      text: "\n.. code:: java\n\n   int n=...;  // >0 à initialiser correctement\n\
        \   int count=0;\n   int sum=0; // la somme\n   while(count<n)\n      sum=sum+count;\n\
        \      count=count+1;\n   // la variable sum contient la somme des\n   //\
        \ n premiers entiers positifs\n"}
    header: '

      Lequel des fragments de code Java ci-dessous permet de calculer la somme des
      :math:`n` premiers entiers positifs ?

      '
    limit: 3
    name: Boucles while
    type: multiple-choice
  q11:
    choices:
    - {text: "\n.. code:: java\n\n   long n=17;\n   long fact=1;  // factorielle\n\
        \   int count=n;  // compteur pour la boucle\n   while(count>1) {\n      fact=fact*count;\n\
        \      count=count-1;\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   long n=17;\n   long fact=1;  // factorielle\n\
        \   int count=1;  // compteur pour la boucle\n   while(count<=n) {\n     \
        \ fact=fact*count;\n      count=count+1;\n   }\n", valid: true}
    - {feedback: '

        Quel est le résultat de :math:`0 \times n`?

        ', text: "\n.. code:: java\n\n   long n=17;\n   long fact=0;  // factorielle\n\
        \   int count=n;  // compteur pour la boucle\n   while(count>1) {\n      fact=fact*count;\n\
        \      count=count-1;\n   }\n"}
    - {feedback: '

        Cette boucle ne s''arrête jamais.

        ', text: "\n.. code:: java\n\n   long n=17;\n   long fact=1;  // factorielle\n\
        \   int count=1;  // compteur pour la boucle\n   while(count>1) {\n      fact=fact*count;\n\
        \      count=count+1;\n   }\n"}
    - {feedback: '

        Cette boucle ne fait que placer la valeur ``count`` dans ``fact`` à chaque
        itération.

        ', text: "\n.. code:: java\n\n   long n=17;\n   long fact=1;  // factorielle\n\
        \   int count=n;  // compteur pour la boucle\n   while(count>1) {\n      fact=count;\n\
        \      count=count-1;\n   }\n"}
    - {feedback: '

        Cette boucle ne calcule pas la factorielle demandée. Que calcule-t-elle ?

        ', text: "\n.. code:: java\n\n   long n=17;\n   long fact=1;  // factorielle\n\
        \   int count=1;  // compteur pour la boucle\n   while(count<=n) {\n     \
        \ count=count+1;\n      fact=fact*count;\n   }\n"}
    header: '

      Les boucles ``while`` sont utiles lorsque l''on doit répéter des opérations
      similaires à de multiples reprises. En arithmétique, la factorielle d''un entier
      positif (``n``) et supérieur à ``1`` est définie comme étant le produit de tous
      les entiers inférieurs ou égaux à ``n``. La factorielle de ``n`` se note :math:`n!`.
      Ainsi :math:`4!=24`. Parmi les boucles ``while`` ci-dessous, laquelle permet
      de calculer correctement :math:`n!` ?

      '
    limit: 3
    name: Boucles while
    type: multiple-choice
  q2:
    choices:
    - {text: "\n.. code:: java\n\n   int i=1;\n   double d=2.0;\n   char c='3';\n\
        \   boolean b=false;\n   long l=-1;\n", valid: true}
    - {text: "\n.. code:: java\n\n   int i=0;\n   double d=3.2e-1;\n   char c='9';\n\
        \   boolean b=true;\n   long l=-1;\n", valid: true}
    - {feedback: '

        Le type ``int`` ne peut être utilisé que pour stocker des nombres entiers.

        ', text: "\n.. code:: java\n\n   int i=0.9;\n   double d=3.2e-1;\n   char\
        \ c='0';\n   boolean b=false;\n   long l=-1234;\n"}
    - {feedback: '

        Le type ``char`` ne peut être utilisé que pour stocker un (et un seul) caractère.
        ``''12''`` n''est pas un caractère valide. ``char c=''2'';`` serait une déclaration
        valide.

        ', text: "\n.. code:: java\n\n   int i=-12345;\n   double d=3;\n   char c='12';\n\
        \   boolean b=true;\n   long l=678;\n"}
    - {feedback: '

        Le type ``char`` ne peut être utilisé que pour stocker un (et un seul) caractère.
        En java, une expression entre guillemets comme ``"9"`` est une *chaîne de
        caractères* (un ``String``)  et non un caractère. ``char c=''9'';`` (notez
        l''utilisation des apostrophes au lieu des guillemets) serait une déclaration
        valide.

        ', text: "\n.. code:: java\n\n   int i=-12345;\n   double d=3;\n   char c=\"\
        9\";\n   boolean b=true;\n   long l=678;\n"}
    - {feedback: '

        Le type ``double`` ne peut être utilisé que pour stocker un nombre réel. ``''8''``
        est le caractère qui correspond au chiffre huit et non un nombre réel. Cette
        initialisation n''est donc pas valide. Notez que la ligne ``int i=2/3;`` est
        tout à fait valide. L''initialisation d''une variable peut être faite en utilisant
        n''importe quelle expression qui retourne une variable de ce type. Cependant,
        comme ``i`` est une variable de type ``int``, sa valeur sera ``0`` puisque
        la division ``2/3`` est une division entière.

        ', text: "\n.. code:: java\n\n   int i=2/3;\n   double d='8';\n   char c='a';\n\
        \   boolean b=false;\n   long l=-1;\n"}
    - {feedback: '

        Le type ``boolean`` ne peut être utilisé que pour stocker une valeur booléenne
        contrairement à d''autres langages tels que C. Il peut s''agir de ``true``,
        ``false`` ou n''importe quelle expression qui donne une valeur booléenne.
        Ainsi, l''expression ``i==9`` est une expression booléenne qui a la valeur
        ``false``. Cette expression aurait pu aussi être utilisée pour initialiser
        la variable booléenne ``b``.

        ', text: "\n.. code:: java\n\n   int i=7;\n   double d=-2.34;\n   char c='z';\n\
        \   boolean b=0;\n   long l=-1;\n"}
    header: '

      Parmi les fragments de programmes Java ci-dessous, quels sont ceux qui respectent
      la syntaxe du langage ?

      '
    limit: 3
    name: Initialisation de variables
    type: multiple-choice
  q3:
    choices:
    - {text: "\n.. code:: java\n\n  /***********************\n   * Mon programme\n\
        \   *\n   ***********************/\n   int count=7; // compteur\n   int n=0;\n\
        \   // test\n   if(count>3) {\n      n=count;\n   }\n", valid: true}
    - {feedback: '

        Un ligne de commentaire est une ligne ignorée par le compilateur Java. Certains
        programmeurs mettent en commentaire des lignes inutiles comme ci-dessus. Cela
        peut être utile durant l''écriture de programmes, mais évitez de rendre un
        programme finalisé avec des lignes de code en commentaires.

        ', text: "\n.. code:: java\n\n  /***********************\n   * Mon programme\n\
        \   *\n   ***********************/\n   int count=7; // compteur\n   int n=0;\n\
        \   // double d;\n   if(count>3) {\n      n=count;\n   }\n", valid: true}
    - {feedback: '


        Ce fragment de code est correct, mais en général on préfère utiliser ``//``
        et non ``/* ... */``  pour un commentaire sur une ligne. Inversement, on préfère
        utiliser ``/* ... */`` pour un commentaire qui prend plusieurs lignes et non
        mettre ``//`` au début de chaque ligne de commentaire.

        ', text: "\n.. code:: java\n\n  //\n  // Mon programme\n  //\n  //\n   int\
        \ count=7; /* compteur */\n   int n=0;\n   // test\n   if(count>3) {\n   \
        \   n=count;\n   }\n", valid: true}
    - {feedback: '

        Dans ce fragment de code, la ligne ``/* test`` marque le début d''un commentaire
        sur plusieurs lignes. Ce commentaire doit se terminer avec ``*/``, ce qui
        n''est pas le cas dans le code ci-dessus.

        ', text: "\n.. code:: java\n\n  /***********************\n   * Mon programme\n\
        \   *\n   ***********************/\n   int count=7; // compteur\n   int n=0;\n\
        \   /* test\n   if(count>3) {\n      n=count;\n   }\n"}
    - {feedback: '

        Dans ce fragment de code, la première ligne marque le début d''un commentaire
        sur plusieurs lignes. Ce commentaire doit normalement se terminer par ``*/``.
        Ce n''est pas le cas de l''exemple ci-dessus et le compilateur Java va considérer
        l''entièreté du programme comme étant un commentaire.

        ', text: "\n.. code:: java\n\n  /***********************\n   * Mon programme\n\
        \   *\n   ***********************\n   int count=7; // compteur\n   int n=0;\n\
        \   // test\n   if(count>3) {\n      n=count;\n   }\n"}
    - {feedback: '

        Un commentaire doit débuter par ``//`` (deux fois caractère ``/``). Si vous
        utilisez un seul caractère ``/`` ou deux caractères ``/ /`` séparés par un
        espace, le compilateur Java ne considère par qu''il s''agit d''un marqueur
        valide de commentaire.

        ', text: "\n.. code:: java\n\n  /***********************\n   * Mon programme\n\
        \   *\n   ***********************\n   int count=7; / compteur\n   int n=0;\n\
        \   / / test\n   if(count>3) {\n      n=count;\n   }\n"}
    header: '

      Afin de faciliter la compréhension des programmes écrits dans un langage de
      programmation tel que Java, il est important de bien le documenter en utilisant
      des commentaires. Parmi les fragments de code Java ci-dessous, lequel est syntaxiquement
      correct ?

      '
    limit: 3
    name: Les commentaires
    type: multiple-choice
  q4:
    choices:
    - {text: "\n.. code:: java\n\n   public class Hello {\n\n    public static void\
        \ main (String[] args) {\n      System.out.println(\"Hello, world!\");\n \
        \   }\n   }\n", valid: true}
    - {feedback: Ce code est correct. Il utilise deux instructions pour afficher le
        messages., text: "\n.. code:: java\n\n   public class Hello {\n\n    public\
        \ static void main (String[] args) {\n      System.out.print(\"Hello,\");\n\
        \      System.out.println(\"world!\");\n    }\n   }\n", valid: true}
    - {feedback: '

        En Java, le fichier ``Hello.java`` doit toujours contenir une classe dont
        le nom est ``Hello``.

        ', text: "\n.. code:: java\n\n   public class Monprog {\n\n    public static\
        \ void main (String[] args) {\n      System.out.println(\"Hello, world!\"\
        );\n    }\n   }\n"}
    - {feedback: '

        En Java, le fichier ``Hello.java`` doit toujours contenir une classe dont
        le nom est ``Hello``. Les noms de classe commencent toujours par une majuscule.

        ', text: "\n.. code:: java\n\n   public class hello {\n\n    public static\
        \ void main (String[] args) {\n      System.out.println(\"Hello, world!\"\
        );\n    }\n   }\n"}
    - {feedback: '

        En Java, la méthode qui est exécutée par défaut dans une classe Java a toujours
        comme signature ``public main (String[] args)``.

        ', text: "\n.. code:: java\n\n   public class Hello {\n\n    public main (String[]\
        \ args) {\n      System.out.println(\"Hello, world!\");\n    }\n   }\n"}
    - {feedback: '

        En Java, la ligne ``System.out.println("Hello, world!")`` doit nécessairement
        se terminer par un ``;``

        ', text: "\n.. code:: java\n\n   public class Hello {\n\n    public main (String[]\
        \ args) {\n      System.out.println(\"Hello, world!\")\n    }\n   }\n"}
    header: '


      Un langage de programmation tel que Java utilise une syntaxe bien précise. Il
      est important que vous sachiez reconnaître rapidement des erreurs de syntaxe
      dans un programme Java pour éviter de les commettre vous-même. Les programmes
      ci-dessous ont été écrits par des étudiants pour afficher le message ``Hello,
      world!`` à l''écran. Chaque programme est stocké dans le fichier ``Hello.java``.
      Un seul de ces programmes est acceptable par le compilateur Java. Lequel ?

      '
    limit: 3
    name: Syntaxe de Java
    type: multiple-choice
  q5:
    choices:
    - {feedback: '

        Cette instruction place dans la variable ``a`` le contenu de la variable ``b``
        mais pas l''inverse.

        ', text: "\n.. code:: java\n\n   a=b;\n"}
    - {feedback: '

        Ce n''est pas une instruction valide en langage Java. Ne confondez-pas ``==``
        et ``=``.

        ', text: "\n\n.. code:: java\n\n   b==a;\n"}
    - {feedback: '

        Cette instruction place dans la variable ``b`` le contenu de la variable ``a``
        mais pas l''inverse.

        ', text: "\n\n.. code:: java\n\n   b=a;\n"}
    - {feedback: '

        Exécutez pas à pas cette suite d''instructions. Que contiennent les variables
        ``a`` et ``b`` à la fin de cette exécution ?

        ', text: "\n.. code:: java\n\n\n    int c; // variable d'échange\n    c=b;\n\
        \    a=c;\n    b=a;\n"}
    - {text: "\n\n.. code:: java\n\n   int c; // variable d'échange\n   c=a;\n   a=b;\n\
        \   b=c;\n", valid: true}
    - {text: "\n\n.. code:: java\n\n    int c; // variable d'échange\n    c=b;\n \
        \   b=a;\n    a=c;\n", valid: true}
    header: "\nDans un langage de programmation comme Java, il est souvent nécessaire\
      \ d'échanger le contenu de deux variables. Considérons le programme ci-dessous\
      \ dans lequel deux variables sont initialisées :\n\n.. code:: java\n\n   int\
      \ a=1401;\n   int b=1101;\n\nParmi les fragments de Java ci-dessous, lequel\
      \ permet de correctement échanger le contenu de la variable ``a`` avec le contenu\
      \ de la variable ``b`` ?\n"
    limit: 3
    name: Echange du contenu de variables
    type: multiple-choice
  q6:
    choices:
    - {text: "\n.. code:: java\n\n   if(a>b)\n   {\n     min=b;\n   }\n   else\n \
        \  {\n     min=a;\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   if(a<b)\n   {\n     min=a;\n   }\n   else\n \
        \  {\n     min=b;\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   if(a<=b)\n   {\n     min=a;\n   }\n   else\n\
        \   {\n     min=b;\n   }\n", valid: true}
    - {feedback: '

        Ce code ne fonctionne pas et le problème est assez subtil. En redéfinissant
        la variable ``min`` à l''intérieur de chaque bloc, on définit une variable
        qui est considérée par le compilateur comme étant différente de la variable
        min qui a été définie avec les variables ``a`` et ``b``. La nouvelle variable
        ``min`` est mise à jour à l''intérieur du bloc mais n''est pas accessible
        en dehors de ce bloc.

        ', text: "\n.. code:: java\n\n   if(a<=b)\n   {\n     double min;\n min=a;\n\
        \   }\n   else\n   {\n     double min;\n     min=b;\n   }\n"}
    - {feedback: '

        Ne confondez pas ``!=`` et ``<=``

        ', text: "\n.. code:: java\n\n   if(a!=b)\n   {\n min=a;\n   }\n   else\n\
        \   {\n     min=b;\n   }\n"}
    - {feedback: '

        Ce programme place la valeur maximale dans la variable ``min``.

        ', text: "\n.. code:: java\n\n   if(a>b)\n   {\n min=a;\n   }\n   else\n \
        \  {\n     min=b;\n   }\n"}
    - {feedback: '

        Lorsque la valeur de la variable ``a`` est supérieure ou égale à la valeur
        de la variable ``b``, la variable ``min`` n''est pas initialisée.

        ', text: "\n.. code:: java\n\n   if(a<b)\n   {\n min=a;\n   }\n"}
    header: "\nConsidérons un programme Java qui manipule deux variables : ``a`` et\
      \ ``b``. Parmi les fragments de code ci-dessous, lequel place correctement dans\
      \ la variable ``min`` le minimum entre les contenus de ``a`` et ``b`` ?\n\n\
      .. code:: java\n\n   double a;\n   double b;\n   double min;\n"
    limit: 3
    name: Calcul du minimum
    type: multiple-choice
  q7:
    choices:
    - {text: "\n.. code:: java\n\n   double abs;\n   if( x<0 ) {\n     abs=-x;\n \
        \  }\n   else {\n     abs=x;\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   double abs=x;\n   if( x<=0 ) {\n     abs=-x;\n\
        \   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   double abs=x;\n   if( x>=0 ) {\n     abs=x;\n\
        \   }\n   else {\n     abs=-x;\n   }\n", valid: true}
    - {feedback: '

        Ce fragment de code place toujours la valeur ``x`` dans la variable ``abs``.

        ', text: "\n.. code:: java\n\n   double abs=x;\n   if( x>=0 ) {\n     abs=x;\n\
        \   }\n"}
    - {feedback: '

        Ne confondez pas ``!=`` et ``>=``.

        ', text: "\n.. code:: java\n\n   double abs;\n   if(x!=0) {\n      abs=x;\n\
        \   }\n   else {\n      abs=-x;\n   }\n"}
    header: '

      Si ``x`` est une variable de type ``double``, lequel de ces fragments de code
      place dans la variable ``abs`` la valeur absolue de ``x``?

      '
    limit: 3
    name: Valeur absolue
    type: multiple-choice
  q8:
    choices:
    - {text: "\n.. code:: java\n\n   if(x>=a) {\n     if(x<b) {\n        System.out.println(\"\
        vrai\");\n    }\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   if(x<b) {\n     if(x>=a) {\n        System.out.println(\"\
        vrai\");\n    }\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   if( (x<b) && (x>=a) ){\n     System.out.println(\"\
        vrai\");\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   if( (x>=a) && (x<b) ){\n     System.out.println(\"\
        vrai\");\n   }\n", valid: true}
    - {feedback: '

        Dans quels cas l''expression ``( (a>=x) && (x<b) )`` est-elle vraie ?

        ', text: "\n.. code:: java\n\n   if( (a>=x) && (x<b) ) {\n     System.out.println(\"\
        vrai\");\n   }\n"}
    - {feedback: '

        L''expression ``( (a<x) && (x<b) )`` est-elle vraie lorsque ``x==a`` ?

        ', text: "\n.. code:: java\n\n   if( (a<x) && (x<b) ) {\n     System.out.println(\"\
        vrai\");\n   }\n"}
    - {feedback: '

        Ne confondez pas la conjonction (`et`) logique représenté par ``&&`` en Java
        et la disjonction (`ou`) logique représentée en Java par ``||``.

        ', text: "\n.. code:: java\n\n   if( (a<=x) || (x<b) ) {\n     System.out.println(\"\
        vrai\");\n   }\n"}
    - {feedback: '

        Affiche-t-elle "vrai" lorsque ``x==a``?

        ', text: "\n.. code:: java\n\n   if(x<a) {\n     if(x<b) {\n        System.out.println(\"\
        vrai\");\n    }\n   }\n"}
    - {feedback: '

        Qu''affiche ce fragment de code lorsque ``x==b`` ?

        ', text: "\n.. code:: java\n\n   if(x<=b) {\n     if(x>=a) {\n        System.out.println(\"\
        vrai\");\n    }\n   }\n"}
    header: '

      En mathématiques, on définit des intervalles, fermés, ouverts et semi-ouverts.
      L''intervalle semi-ouvert :math:`[3,7[` comprend l''ensemble des nombres réels
      qui sont supérieurs ou égaux à `3` et strictement inférieurs à 7. Sachant que
      ``a``, ``b`` et ``x`` sont des variables de type ``double``, lequel des fragments
      de code suivants affiche ``vrai`` sur sa sortie standard si et seulement si
      ``x`` appartient à l''intervalle :math:`[a,b[` ? On supposera pour cette question
      que la valeur stockée dans la variable ``a`` est strictement inférieure à celle
      stockée dans la variable ``b``.

      '
    limit: 3
    name: Intervalles
    type: multiple-choice
  q9:
    choices:
    - {text: "\n.. code:: java\n\n   int i=2;\n   int j=3;\n   int k=i/j;\n   if(k==0)\
        \ {\n      System.out.println(\"ok\");\n   }\n", valid: true}
    - {text: "\n.. code:: java\n\n   double a=2;\n   double b=3;\n   double c=a/b;\n\
        \   if(c!=0.0) {\n      System.out.println(\"ok\");\n   }\n", valid: true}
    - {feedback: '

        Dans ce fragment de code, les variables sont de type ``int``. En arithmétique
        entière, la division ``6/7`` donne comme résultat ``0`` avec un reste de ``6``.

        ', text: "\n.. code:: java\n\n   int i=6;\n   int j=7;\n   int k=i/j;\n  \
        \ if(k!=0) {\n      System.out.println(\"ok\");\n   }\n"}
    - {feedback: '

        Dans ce fragment de code, les variables ``a`` et ``b`` sont de type ``double``.
        Elles permettent donc de stocker un nombre réel. Le résultat de ``a/b`` est
        ``0.33333`` qui est différent de ``0.0``.

        ', text: "\n.. code:: java\n\n   double a=1;\n   double b=3;\n   double c=a/b;\n\
        \   if(c==0.0) {\n      System.out.println(\"ok\");\n   }\n"}
    - {feedback: '

        Dans ce fragment de code, les variables sont de type ``int``. En arithmétique
        entière, la division ``8/7`` donne comme résultat ``1`` avec un reste de ``1``.

        ', text: "\n.. code:: java\n\n   int i=8;\n   int j=7;\n   int k=i/j;\n  \
        \ if(k==0) {\n      System.out.println(\"ok\");\n   }\n"}
    - {feedback: '

        Dans ce fragment de code, les variables ``a`` et ``b`` sont de type ``double``.
        Elles permettent donc de stocker un nombre réel. Le résultat de ``a/b`` est
        différent de ``0.0``.

        ', text: "\n.. code:: java\n\n   double a=6.0;\n   double b=7.0;\n   double\
        \ c=a/b;\n   if(c==0.0) {\n      System.out.println(\"ok\");\n   }\n"}
    header: '

      Un seul des fragments de programmes ci-dessous affiche "ok" à l''écran ? Pouvez-vous
      trouver lequel ?

      '
    limit: 3
    name: Opérations arithmétiques
    type: multiple-choice
stored_submissions: 0
weight: 1.0
