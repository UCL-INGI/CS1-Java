accessible: 2016-11-03 08:00:00/2017-09-20 16:00:00
author: Olivier BONAVENTURE
context: "================================\nMission 7. Extension et Héritage\n================================\n\
  \n\nCes questions supposent que vous avez lu les sections suivantes du livre de\
  \ référence |jn|_\n\n  - |jn2.4|_\n\n    - |jn2.4.4|_\n\n  - |jn4.3|_\n\n    - |jn4.3.3|_\n\
  \n  - |jn5.3|_\n\n    - |jn5.3.3|_\n\n  - |jn5.5|_\n\n    - |jn5.5.1|_\n    - |jn5.5.2|_\n\
  \    - |jn5.5.3|_\n    - |jn5.5.4|_\n\n  - |jn5.6|_\n\n    - |jn5.6.1|_\n    - |jn5.6.2|_\n\
  \    - |jn5.6.3|_\n\n  - |jn5.7|_\n\n    - |jn5.7.4|_\n\n\n.. _jn: http://math.hws.edu/javanotes/\n\
  .. |jn| replace:: JavaNotes\n\n.. _jn2.4: http://math.hws.edu/javanotes/c2/s4.html\n\
  .. |jn2.4| replace:: `2.4 : Text Input and Output`\n\n.. _jn2.4.4 : http://math.hws.edu/javanotes/c2/s4.html#basics.4.4\n\
  .. |jn2.4.4| replace:: `2.4.4 : Formatted Output`\n\n.. _jn4.3 : http://math.hws.edu/javanotes/c4/s3.html\n\
  .. |jn4.3| replace:: `4.3 : Parameters`\n\n.. _jn4.3.3 : http://math.hws.edu/javanotes/c4/s3.html#subroutines.3.3\n\
  .. |jn4.3.3| replace:: `4.3.3 : Overloading`\n\n.. _jn5.3 : http://math.hws.edu/javanotes/c5/s3.html\n\
  .. |jn5.3| replace:: `5.3 : Programming with Objects`\n\n.. _jn5.3.3 : http://math.hws.edu/javanotes/c5/s3.html#OOP.3.3\n\
  .. |jn5.3.3| replace:: `5.3.3 : The class \"Object\"`\n\n.. _jn5.5 : http://math.hws.edu/javanotes/c5/s5.html\n\
  .. |jn5.5| replace:: `5.5 : Inheritance, Polymorphism, and Abstract Classes`\n\n\
  .. _jn5.5.1 : http://math.hws.edu/javanotes/c5/s5.html#OOP.5.1\n.. |jn5.5.1| replace::\
  \ `5.5.1 : Extending Existing Classes`\n\n.. _jn5.5.2 : http://math.hws.edu/javanotes/c5/s5.html#OOP.5.2\n\
  .. |jn5.5.2| replace:: `5.5.2 : Inheritance and Class Hierarchy`\n\n.. _jn5.5.3\
  \ : http://math.hws.edu/javanotes/c5/s5.html#OOP.5.3\n.. |jn5.5.3| replace:: `5.5.3\
  \ : Example: Vehicles`\n\n.. _jn5.5.4 : http://math.hws.edu/javanotes/c5/s5.html#OOP.5.4\n\
  .. |jn5.5.4| replace:: `5.5.4 : Polymorphism`\n\n.. _jn5.6 : http://math.hws.edu/javanotes/c5/s6.html\n\
  .. |jn5.6| replace:: `5.6 : this and super`\n\n.. _jn5.6.1 : http://math.hws.edu/javanotes/c5/s6.html#OOP.6.1\n\
  .. |jn5.6.1| replace:: `5.6.1 : The Special Variable this`\n\n.. _jn5.6.2 : http://math.hws.edu/javanotes/c5/s6.html#OOP.6.2\n\
  .. |jn5.6.2| replace:: `5.6.2 : The Special Variable super`\n\n.. _jn5.6.3 : http://math.hws.edu/javanotes/c5/s6.html#OOP.6.3\n\
  .. |jn5.6.3| replace:: `5.6.3 : Constructors in Subclasses`\n\n.. _jn5.7 : http://math.hws.edu/javanotes/c5/s7.html\n\
  .. |jn5.7| replace:: `5.7 : Interfaces, Nested Classes, and Other Details`\n\n..\
  \ _jn5.7.4 : http://math.hws.edu/javanotes/c5/s7.html#OOP.7.4\n.. |jn5.7.4| replace::\
  \ `5.7.4 : Mixing Static and Non-static`\n"
environment: mcq
evaluate: best
groups: false
limits: {memory: '100', output: '2', time: '30'}
name: 'Mission 7: QCM'
network_grading: false
order: 124
problems:
  q1:
    choices:
    - {text: '


        - ``C1`` est une super-classe de ``C3``

        - ``C2`` est une classe-fille de ``C1``

        - Toute instance de ``C3`` est une instance de ``C1``

        ', valid: true}
    - {text: '


        - ``C3`` est une sous-classe de ``C2``

        - ``C2`` est la classe-mère de ``C3``

        - Toute instance de ``C2`` est une instance de ``C1``

        ', valid: true}
    - {feedback: '

        ``C1`` n''est pas une sous-classe de ``C3``.

        ', text: '


        - ``C1`` est une sous-classe de ``C3``

        - ``C2`` est une classe-fille de ``C1``

        - Toute instance de ``C2`` est une instance de ``C1``

        '}
    - {feedback: '

        ``C2`` n''est pas une classe-fille de ``C3``.

        ', text: '


        - ``C1`` est une super-classe de ``C3``

        - ``C2`` est une classe-fille de ``C3``

        - Toute instance de ``C3`` est une instance de ``C1``

        '}
    - {feedback: '

        Toute instance de ``C1`` n''est pas une instance de ``C3``.

        ', text: '


        - ``C2`` est une classe-fille de ``C1``

        - Toute instance de ``C1`` est une instance de ``C3``

        - ``C3`` est une sous-classe de ``C2``

        '}
    - {feedback: '

        ``C1`` n''est pas une sous-classe de ``C2``

        ', text: '


        - ``C2`` est une classe-fille de ``C1``

        - Toute instance de ``C3`` est une instance de ``C1``

        - ``C1`` est une sous-classe de ``C2``

        '}
    - {feedback: '

        ``C2`` n''est pas la classe-fille de ``C3``

        ', text: '


        - ``C1`` est une super-classe de ``C3``

        - ``C2`` est la classe-fille de ``C3``

        - Toute instance de ``C2`` est une instance de ``C1``

        '}
    - {feedback: '

        Toute instance de ``C2`` n''est pas une instance de ``C3``

        ', text: '


        - ``C2`` est une classe-fille de ``C1``

        - ``C3`` est une sous-classe de ``C2``

        - Toute instance de ``C2`` est une instance de ``C3``

        '}
    header: '

      Si la classe ``C3`` étend la classe ``C2``, qui étend elle-même la classe ``C1``,
      quel groupe d''affirmations est correct ?

      '
    limit: 3
    name: 'Héritage : vocabulaire'
    type: multiple-choice
  q2:
    choices:
    - {text: ".. code-block:: java\n\n   public class C2 extends C1 {\n       private\
        \ int n2;\n       public C2 (String s, int n) {\n           super(s, n);\n\
        \           this.n2 = n;\n       }\n       public int m() {\n           return\
        \ super.m() + n2 * n2;\n       }\n   }\n", valid: true}
    - {feedback: '

        Il faut utiliser ``super`` pour référer à la classe-mère et non ``C2``.

        ', text: ".. code-block:: java\n\n   public class C2 extends C1 {\n      \
        \ private int n2;\n       public C2 (String s, int n) {\n           C1(s,\
        \ n);\n           this.n2 = n;\n       }\n       public int m() {\n      \
        \     return C2.m() + n2 * n2;\n       }\n   }\n"}
    - {feedback: '

        La déclaration ne mentionne pas que ``C2`` étend ``C1``.

        ', text: ".. code-block:: java\n\n   public class C2 {\n       private int\
        \ n2;\n       public C2 (String s, int n) {\n           super(s, n);\n   \
        \        this.n2 = n;\n       }\n       public int m() {\n           return\
        \ super.m() + n2 * n2;\n       }\n   }\n"}
    - {feedback: '

        Dans la signature de ``m``, le ``override`` est incorrect et inutile (il existe
        une annotation ``@override`` mais elle n''est pas indispensable).

        ', text: ".. code-block:: java\n\n   public class C2 extends C1 {\n      \
        \ private int n2;\n       public C2 (String s, int n) {\n           super(s,\
        \ n);\n           this.n2 = n;\n       }\n       public override int m() {\n\
        \           return super.m() + n2 * n2;\n       }\n   }\n"}
    - {feedback: '

        Dans le corps de ``m``, la variable ``n`` de ``C1`` n''est pas accessible
        (``private``).

        ', text: ".. code-block:: java\n\n   public class C2 extends C1 {\n      \
        \ private int n2;\n       public C2 (String s, int n) {\n           super(s,\
        \ n);\n           this.n2 = n;\n       }\n       public int m() {\n      \
        \     return n1 * n1 + n2 * n2;\n       }\n   }\n"}
    - {feedback: '

        Dans le constructeur de ``C2``, il faut appeler le constructeur de ``C1``
        pour initialiser les variables de ``C1``.

        ', text: ".. code-block:: java\n\n   public class C2 extends C1 {\n      \
        \ private int n2;\n       public C2 (String s, int n) {\n           this.s\
        \ = s;\n           this.n = n;\n           this.n2 = n;\n       }\n      \
        \ public int m() {\n           return super.m() + n2 * n2;\n       }\n   }\n"}
    - {feedback: '

        Dans le constructeur, l''appel au constructeur de ``C1`` doit venir en premier
        lieu.

        ', text: ".. code-block:: java\n\n   public class C2 extends C1 {\n      \
        \ private int n2;\n       public C2 (String s, int n) {\n           this.n2\
        \ = n;\n           super(s, n);\n       }\n       public int m() {\n     \
        \      return super.m() + n2 * n2;\n       }\n   }\n"}
    header: "\nSoit la classe ``C1`` définie comme suit\n\n.. code-block:: java\n\n\
      \    public class C1 {\n        private String s;\n        private int n;\n\
      \        public C1(String s, int n) {\n            this.s = s;\n           \
      \ this.n = n;\n        }\n        public int m() {\n            return n * n;\n\
      \        }\n    }\n\nLaquelle des définitions suivantes définit correctement\
      \ une extension de ``C1`` ?\n"
    limit: 3
    name: Extension de classe
    type: multiple-choice
  q3:
    choices:
    - {text: ".. code-block:: java\n\n   C3 obj3 = new C3();\n   C2 obj2 = new C3();\n\
        \   C4 obj4 = new C4();\n   C1 obj1 = obj3;\n", valid: true}
    - {text: ".. code-block:: java\n\n   C4 obj4 = new C4();\n   C2 obj2 = obj4;\n\
        \   C1 obj1 = new C2();\n   C3 obj3 = null;\n", valid: true}
    - {feedback: '

        ``C3 obj3`` ne peut pas recevoir une expression de type ``C2``.

        ', text: ".. code-block:: java\n\n   C4 obj4 = new C4();\n   C3 obj3 = new\
        \ C2();\n   C2 obj2 = new C3();\n   C1 obj1 = obj3;\n"}
    - {feedback: '

        ``C4 obj4`` ne peut pas recevoir une expression de type ``C2``.

        ', text: ".. code-block:: java\n\n   C3 obj3 = new C3();\n   C2 obj2 = new\
        \ C3();\n   C1 obj1 = obj3;\n   C4 obj4 = obj2;\n"}
    - {feedback: '

        ``C2 obj2`` ne peut pas recevoir une expression de type ``C1`` (même si l''objet
        qu''elle désigne est en fait de type ``C3``).

        ', text: ".. code-block:: java\n\n   C4 obj4 = new C4();\n   C3 obj3 = new\
        \ C3();\n   C1 obj1 = obj3;\n   C2 obj2 = obj1;\n"}
    - {feedback: '

        ``C4 obj4`` ne peut pas recevoir une expression de type ``C3`` (même si elle
        produit la référence ``null``).

        ', text: ".. code-block:: java\n\n   C3 obj3 = null;\n   C2 obj2 = obj4;\n\
        \   C4 obj4 = obj3;\n   C1 obj1 = new C2();\n"}
    - {feedback: '

        ``C3 obj3`` ne peut pas recevoir une expression de type ``C1``.

        ', text: ".. code-block:: java\n\n   C4 obj4 = new C4();\n   C2 obj2 = obj4;\n\
        \   C3 obj3 = new C1();\n   C1 obj1 = new C2();\n"}
    - {feedback: '

        ``C3 obj3`` ne peut pas recevoir une expression de type ``C3`` (même si l''objet
        qu''elle désigne est en fait de type ``C3``).

        ', text: ".. code-block:: java\n\n   C2 obj2 = new C3();\n   C1 obj1 = new\
        \ C2();\n   C3 obj3 = obj2;\n   C4 obj4 = new C4();\n"}
    header: "\nSoit les classes ``C1``, ``C2``, ``C3`` et ``C4`` définies comme suit\n\
      \n.. code-block:: java\n\n    public class C1 {\n        public C1() {\n   \
      \         // ...\n        }\n        // ...\n    }\n\n    public class C2 extends\
      \ C1 {\n        public C2() {\n            // ...\n        }\n        // ...\n\
      \    }\n\n    public class C3 extends C2 {\n        public C3() {\n        \
      \    // ...\n        }\n        // ...\n    }\n\n    public class C4 extends\
      \ C2 {\n        public C4() {\n            // ...\n        }\n        // ...\n\
      \    }\n\nParmi les portions de code suivantes, laquelle est valide pour le\
      \ compilateur Java ?\n"
    limit: 3
    name: Extension et types
    type: multiple-choice
  q4:
    choices:
    - {text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur à la\
        \ compilation\n   C1 conv21 = obj2;       // => OK\n   C2 conv32 = obj3; \
        \      // => erreur à la compilation\n   C2 cast12 = (C2) obj1;  // => erreur\
        \ à l'exécution\n   C1 cast21 = (C1) obj2;  // => OK mais type-cast inutile\n\
        \   C2 cast32 = (C2) obj3;  // => OK\n", valid: true}
    - {feedback: '

        La variable ``obj3`` est de type ``C1`` : erreur de compilation à la ligne
        3.

        ', text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur\
        \ à la compilation\n   C1 conv21 = obj2;       // => OK\n   C2 conv32 = obj3;\
        \       // => OK\n   C2 cast12 = (C2) obj1;  // => erreur à l'exécution\n\
        \   C1 cast21 = (C1) obj2;  // => OK mais type-cast inutile\n   C2 cast32\
        \ = (C2) obj3;  // => OK\n"}
    - {feedback: '

        ``obj1`` réfère à une instance de ``C1`` : erreur de type-cast à l''exécution
        à la ligne 4.

        ', text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur\
        \ à la compilation\n   C1 conv21 = obj2;       // => OK\n   C2 conv32 = obj3;\
        \       // => erreur à la compilation\n   C2 cast12 = (C2) obj1;  // => OK\n\
        \   C1 cast21 = (C1) obj2;  // => OK mais type-cast inutile\n   C2 cast32\
        \ = (C2) obj3;  // => OK\n"}
    - {feedback: '

        ``obj3`` réfère bien à une instance de ``C2`` : pas d''erreur à la ligne 6.

        ', text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur\
        \ à la compilation\n   C1 conv21 = obj2;       // => OK\n   C2 conv32 = obj3;\
        \       // => erreur à la compilation\n   C2 cast12 = (C2) obj1;  // => erreur\
        \ à l'exécution\n   C1 cast21 = (C1) obj2;  // => OK mais type-cast inutile\n\
        \   C2 cast32 = (C2) obj3;  // => erreur à l'exécution\n"}
    - {feedback: '

        La ligne 4 est correcte du point de vue des types mais causera erreur de type-cast
        à l''exécution.

        ', text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur\
        \ à la compilation\n   C1 conv21 = obj2;       // => OK\n   C2 conv32 = obj3;\
        \       // => erreur à la compilation\n   C2 cast12 = (C2) obj1;  // => erreur\
        \ à la compilation\n   C1 cast21 = (C1) obj2;  // => OK mais type-cast inutile\n\
        \   C2 cast32 = (C2) obj3;  // => OK\n"}
    - {feedback: '

        La variable ``obj2`` est de type ``C2`` qui est une sous-classe de ``C1``
        : pas d''erreur à la ligne 2.

        ', text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur\
        \ à la compilation\n   C1 conv21 = obj2;       // => erreur à la compilation\n\
        \   C2 conv32 = obj3;       // => erreur à la compilation\n   C2 cast12 =\
        \ (C2) obj1;  // => erreur à l'exécution\n   C1 cast21 = (C1) obj2;  // =>\
        \ OK mais type-cast inutile\n   C2 cast32 = (C2) obj3;  // => OK\n"}
    - {feedback: '

        ``obj2`` réfère à une instance de ``C2`` qui est bien une sous-classe de ``C1``
        : pas d''erreur à la ligne 5.

        ', text: ".. code-block:: java\n\n   C2 conv12 = obj1;       // => erreur\
        \ à la compilation\n   C1 conv21 = obj2;       // => OK\n   C2 conv32 = obj3;\
        \       // => erreur à la compilation\n   C2 cast12 = (C2) obj1;  // => erreur\
        \ à l'exécution\n   C1 cast21 = (C1) obj2;  // => erreur à l'exécution\n \
        \  C2 cast32 = (C2) obj3;  // => OK\n"}
    header: "\nSoit les classes ``C1`` et ``C2`` définies comme suit\n\n.. code-block::\
      \ java\n\n    public class C1 {\n        public C1() {\n            // ...\n\
      \        }\n        // ...\n    }\n\n    public class C2 extends C1 {\n    \
      \    public C2() {\n            // ...\n        }\n        // ...\n    }\n\n\
      On considère ensuite les instructions suivantes\n\n.. code-block:: java\n\n\
      \    C1 obj1 = new C1();\n    C2 obj2 = new C2();\n    C1 obj3 = new C2();\n\
      \n    C2 conv12 = obj1;\n    C1 conv21 = obj2;\n    C2 conv32 = obj3;\n    C2\
      \ cast12 = (C2) obj1;\n    C1 cast21 = (C1) obj2;\n    C2 cast32 = (C2) obj3;\n\
      \nParmi ces instructions, certaines causent une erreur à le compilation ou à\
      \ l'exécution.  Parmi les propositions ci-dessous, laquelle identifie correctement\
      \ ces erreurs ?\n"
    limit: 3
    name: Conversions de type
    type: multiple-choice
  q5:
    choices:
    - {text: ".. code-block:: java\n\n       public int m1(String s, int n) {\n  \
        \         return super.m1(s, n * 2) + 10;\n       }\n", valid: true}
    - {feedback: '

        Les paramètres peuvent avoir un nom différent, pour autant que types correspondent
        exactement.

        ', text: ".. code-block:: java\n\n       public int m1(String x, int i) {\n\
        \           return super.m1(x, i * 2) + 10;\n       }\n", valid: true}
    - {feedback: '

        Les paramètres doivent être dans le même ordre.

        ', text: ".. code-block:: java\n\n       public int m1(int n, String s) {\n\
        \           return super.m1(s, n * 2) + 10;\n       }\n"}
    - {feedback: '

        Le type de résultat doit être le même.

        ', text: ".. code-block:: java\n\n       public double m1(String s, int n)\
        \ {\n           return super.m1(s, n * 2) + 10.0;\n       }\n"}
    - {feedback: '

        Erreur de syntaxe : utiliser ``super.m1`` pour appeler la méthode ``m1`` de
        la classe-mère.

        ', text: ".. code-block:: java\n\n       public int m1(String s, int n) {\n\
        \           return super(s, n * 2) + 10;\n       }\n"}
    - {feedback: '

        Il faut conserver le même nombre de paramètres.

        ', text: ".. code-block:: java\n\n       public int m1(String s, int n, int\
        \ n2) {\n           return super.m1(s, n * 2) + n2;\n       }\n"}
    header: "\n\nSoit les classes ``C1`` et ``C2`` définies comme suit\n\n.. code-block::\
      \ java\n\n    public class C1 {\n        // ...\n        public int m1(String\
      \ s, int n) {\n            // ...\n        }\n    }\n\n    public class C2 extends\
      \ C1 {\n        // ...\n    }\n\nParmi les définitions suivantes dans ``C2``,\
      \ laquelle constitue une *re-définition* (overriding) correcte de la méthode\
      \ ``m1`` de la classe ``C1`` et non une *surcharge* (overloading) ?\n"
    limit: 3
    name: Re-définition et surcharge
    type: multiple-choice
  q6:
    choices:
    - {text: '


        - ``publ`` peut être appelée dans le corps de ``m3``.

        - ``prot`` peut être appelée dans le corps de ``m2``.

        - ``priv`` NE peut PAS être appelée dans le corps de ``m2``.

        ', valid: true}
    - {text: '


        - ``publ`` peut être appelée dans le corps de ``m2``.

        - ``prot`` NE peut PAS être appelée dans le corps de ``m3``.

        - ``priv`` peut être appelée dans le corps de ``m1``.

        ', valid: true}
    - {feedback: '

        ``publ`` a la visibilité ``public``, elle peut être appelée partout.

        ', text: '


        - ``publ`` NE peut PAS être appelée dans le corps de ``m3``.

        - ``prot`` peut être appelée dans le corps de ``m2``.

        - ``priv`` peut être appelée dans le corps de ``m1``.

        '}
    - {feedback: '

        ``prot`` a la visibilité ``protected``, elle peut être appelée dans la classe
        ``C2`` qui étend ``C1``.

        ', text: '


        - ``publ`` peut être appelée dans le corps de ``m3``.

        - ``prot`` NE peut PAS être appelée dans le corps de ``m2``.

        - ``priv`` peut être appelée dans le corps de ``m1``.

        '}
    - {feedback: '

        ``priv`` a la visibilité ``private``, elle peut être appelée uniquement dans
        sa propre classe ``C1``.

        ', text: '


        - ``priv`` peut être appelée dans le corps de ``m2``.

        - ``publ`` peut être appelée dans le corps de ``m2``.

        - ``prot`` NE peut PAS être appelée dans le corps de ``m3``.

        '}
    - {feedback: '

        ``publ`` a la visibilité ``public``, elle peut être appelée partout.

        ', text: '


        - ``prot`` peut être appelée dans le corps de ``m2``.

        - ``publ`` NE peut PAS être appelée dans le corps de ``m2``.

        - ``priv`` peut être appelée dans le corps de ``m1``.

        '}
    - {feedback: '

        ``prot`` a la visibilité ``protected``, elle ne peut pas être appelée dans
        ``C3`` qui n''étend pas ``C1``.

        ', text: '


        - ``publ`` peut être appelée dans le corps de ``m3``.

        - ``prot`` peut être appelée dans le corps de ``m3``.

        - ``priv`` peut être appelée dans le corps de ``m1``.

        '}
    - {feedback: '

        ``priv`` peut toujours être appelée dans la classe où elle est définie.

        ', text: '


        - ``publ`` peut être appelée dans le corps de ``m3``.

        - ``prot`` peut être appelée dans le corps de ``m2``.

        - ``priv`` NE peut PAS être appelée dans le corps de ``m1``.

        '}
    header: "\nConsidérez les classes ``C1``, ``C2``, ``C3`` définies comme suit\n\
      \n.. code-block:: java\n\n    public class C1 {\n        // ...\n        public\
      \    int publ() { /* ... */ }\n        protected int prot() { /* ... */ }\n\
      \        private   int priv() { /* ... */ }\n        public int m1() { /* ...\
      \ */ }\n    }\n\n    public class C2 extends C1 {\n        // ...\n        public\
      \ int m2() { /* ... */ }\n    }\n\n    public class C3 {\n        // ...\n \
      \       public int m3() { /* ... */ }\n    }\n\nParmi les groupes d'affirmation\
      \ suivants, lequel est correct ?\n"
    limit: 3
    name: Modificateurs de visibilité
    type: multiple-choice
  q7:
    choices:
    - {feedback: '

        Une méthode de classe (``static``) ne peut pas accéder à la variable d''instance
        ``var``.

        ', text: 'La méthode ``m3``

        ', valid: true}
    - {feedback: '

        ``m2`` peut parfaitement accéder à la variable de classe ``svar``.

        ', text: 'Les méthodes ``m2`` et ``m3``

        '}
    - {feedback: '

        ``m4`` est parfaitement valide.

        ', text: 'Les méthodes ``m3`` et ``m4``

        '}
    - {feedback: '

        ``m2`` peut parfaitement accéder à la variable de classe ``svar``.

        ', text: 'La méthode ``m2``

        '}
    - {feedback: '

        ``m4`` est parfaitement valide.

        ', text: 'La méthode ``m4``

        '}
    - {feedback: '

        La méthode de classe (``static``) ``m3`` ne peut pas accéder à la variable
        d''instance ``var``.

        ', text: 'Aucune

        '}
    header: "\nOn considère le code suivant\n\n.. code-block:: java\n\n    public\
      \ class C {\n        private static int svar;\n        private int var;\n\n\
      \        public void m1() { var = var + 1; }\n        public void m2() { svar\
      \ = svar + 1; }\n        public static void m3() { var = var + 1; }\n      \
      \  public static void m4() { svar = svar + 1; }\n    }\n\nParmi ces définitions\
      \ de méthode, lesquelles produisent une erreur de compilation ?\n"
    limit: 3
    name: Variables et méthodes de classe
    type: multiple-choice
  q8:
    choices:
    - {feedback: '

        ``m1`` affecte des variables d''instance distinctes de ``c1`` et ``c2`` tandis
        que ``m2`` affecte une variable de classe commune.

        ', text: ".. code-block:: java\n\n   1\n   10\n   1\n   20\n", valid: true}
    - {feedback: '

        ``m2`` affecte une variable de classe commune.

        ', text: ".. code-block:: java\n\n   1\n   10\n   1\n   10\n"}
    - {feedback: '

        ``m1`` affecte des variables d''instance distinctes de ``c1`` et ``c2``.

        ', text: ".. code-block:: java\n\n   1\n   10\n   2\n   20\n"}
    - {feedback: '

        ``m1`` et ``m2`` affectent des variables différentes ``var`` et ``svar``

        ', text: ".. code-block:: java\n\n   1\n   11\n   12\n   22\n"}
    - {feedback: '

        Attention, on appelle deux méthodes différentes ``m1`` et ``m2``.

        ', text: ".. code-block:: java\n\n   1\n   2\n   1\n   2\n"}
    header: "\nOn considère la classe ``C`` suivante\n\n.. code-block:: java\n\n \
      \   public class C {\n        private static int svar = 0;\n        private\
      \ int var;\n\n        public C() {\n            var = 0;\n        }\n\n    \
      \    public void m1() {\n            var = var + 1;\n            System.out.println(var);\n\
      \        }\n\n        public void m2() {\n            svar = svar + 10;\n  \
      \          System.out.println(svar);\n        }\n    }\n\nOn exécute les instructions\
      \ suivantes\n\n.. code-block:: java\n\n    C c1 = new C();\n    c1.m1();\n \
      \   c1.m2();\n    C c2 = new C();\n    c2.m1();\n    c2.m2();\n\nQuel est le\
      \ résultat affiché ?\n"
    limit: 3
    name: Variables de classe et d'instance
    type: multiple-choice
  q9:
    choices:
    - {text: ".. code-block:: java\n\n   public boolean equals(Object other) {\n \
        \      if (other != null && other instanceof Point) {\n           Point p\
        \ = (Point) other;\n           return ((this.x == p.x) && (this.y == p.y));\n\
        \       } else {\n           return false;\n       }\n   }\n", valid: true}
    - {feedback: '

        ``other`` est de type ``Object``, ``other.x`` n''est pas correct.

        ', text: ".. code-block:: java\n\n   public boolean equals(Object other) {\n\
        \       if (other != null && other instanceof Point) {\n           return\
        \ ((this.x == other.x) && (this.y == other.y));\n       } else {\n       \
        \    return false;\n       }\n   }\n"}
    - {feedback: '

        ``other`` pourrait être ``null``.

        ', text: ".. code-block:: java\n\n   public boolean equals(Object other) {\n\
        \       if (other instanceof Point) {\n           Point p = (Point) other;\n\
        \           return ((this.x == p.x) && (this.y == p.y));\n       } else {\n\
        \           return false;\n       }\n   }\n"}
    - {feedback: '

        Ceci fonctionne mais ne correspond pas à la méthode ``equals`` de ``Object``.  Le
        paramètre doit être de type ``Object``.

        ', text: ".. code-block:: java\n\n   public boolean equals(Point other) {\n\
        \       return ((this.x == other.x) && (this.y == other.y));\n   }\n"}
    - {feedback: '

        Ceci produira une erreur à l''exécution si ``other`` est ``null`` ou n''est
        pas de type ``Point``.

        ', text: ".. code-block:: java\n\n   public boolean equals(Object other) {\n\
        \       Point p = (Point) other;\n       return ((this.x == p.x) && (this.y\
        \ == p.y));\n   }\n"}
    header: "\nSoit la classe ``Point`` définie comme suit\n\n.. code-block:: java\n\
      \n    public class Point {\n        private int x;\n        private int y;\n\
      \        public C1(int x, int y) {\n            this.x = x;\n            this.y\
      \ = y;\n        }\n        // ...\n    }\n\nDans cette classe, laquelle des\
      \ définitions suivantes re-définirait correctement la méthode ``equals`` de\
      \ la classe ``Object`` ?\n"
    limit: 3
    name: La méthode equals
    type: multiple-choice
stored_submissions: 0
submission_limit: {amount: -1, period: -1}
weight: 1.0
